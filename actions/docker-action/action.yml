name: "Docker Build and Publish Composite Action using Buildx"
description: "Composite action for building and publishing Docker images using Docker Buildx."
inputs:
  ref:
    description: "Branch to create a release from."
    required: false
    default: ""
  custom-image-name:
    description: "Custom name for the Docker image."
    required: false
    default: ""
  context:
    description: "Pipeline context."
    required: false
    default: "git"
  dry-run:
    description: "Run without pushing (dry run)."
    required: false
    default: "false"
  download-artifact:
    description: "Flag to download the artifact."
    required: false
    default: "false"
  component:
    description: "Component configuration in JSON format (an array with a single object)."
    required: false
    default: '[{"name": "default", "dockerfile": "./Dockerfile", "build_context": "."}]'
  platforms:
    description: "Platforms for which the Docker image will be built."
    required: false
    default: "linux/amd64"
  tags:
    description: "Docker image tags. If empty, tags will be generated automatically."
    required: false
    default: ""
  download-artifact-name:
    description: "Name of the artifact to download. Either inputs `artifact-ids` or `name` can be used, but not both. Optional"
    required: false
    default: ""
  download-artifact-ids:
    description: "IDs of the artifacts to download, comma-separated. Either inputs `artifact-ids` or `name` can be used, but not both. Optional"
    required: false
    default: ""
  download-artifact-path:
    description: "Destination path. Supports basic tilde expansion. Optional. Default is $GITHUB_WORKSPACE"
    required: false
    default: ""
  download-artifact-pattern:
    description: "A glob pattern to the artifacts that should be downloaded. Ignored if name is specified. Optional."
    required: false
    default: ""
  download-artifact-merge-multiple:
    description: "When download multiple artifacts unpack them as is or into separate directories. Optional."
    required: false
    default: "false"
  sbom:
    description: "Flag to enable SBoM generation."
    required: false
    default: "false"
  build-args:
    description: "Build arguments for the Docker image. Supports comma-separated or newline-delimited format."
    required: false
    default: ""
  checkout:
    description: "Flag to enable repository checkout."
    required: false
    default: "true"
  registry:
    description: "Registry name docker.io or ghcr.io or both"
    required: false
    default: "ghcr.io"
  docker-io-login:
    description: "User name to login to docker.io"
    required: false
  docker-io-token:
    description: "Token to login to docker.io"
    required: false
  skip-qemu-buildx:
    description: "DEPRECATED: Use setup-qemu and setup-buildx instead. Skip the setup of both QEMU and Buildx."
    required: false
    default: "false"
  setup-qemu:
    description: "Setup QEMU for multi-platform builds."
    required: false
    default: "true"
  setup-buildx:
    description: "Setup Docker Buildx."
    required: false
    default: "true"

outputs:
  image-name:
    description: "The name of the built Docker image."
    value: "${{ steps.output_result.outputs.image_name }}"
  metadata_path:
    description: "Path to the generated metadata file."
    value: "${{ steps.output_result.outputs.metadata_path }}"
  metadata-filename:
    description: "Name of the generated metadata file."
    value: "${{ steps.output_result.outputs.metadata_filename }}"
  component-name:
    description: "The name of the component being built."
    value: "${{ steps.extract_component.outputs.name }}"
  component-file:
    description: "The Dockerfile used for the build."
    value: "${{ steps.extract_component.outputs.file }}"
  component-context:
    description: "The build context used for the build."
    value: "${{ steps.extract_component.outputs.ctx }}"
  component-build-args:
    description: "The build arguments used for the build."
    value: "${{ steps.extract_component.outputs.build_args }}"
  final-tags:
    description: "The final tags applied to the Docker image."
    value: "${{ steps.prepare-final-params.outputs.tags }}"
  final-labels:
    description: "The final labels applied to the Docker image."
    value: "${{ steps.prepare-final-params.outputs.labels }}"
  final-build-args:
    description: "The final build arguments applied to the Docker image."
    value: "${{ steps.prepare-final-params.outputs.build_args }}"
  final-platforms:
    description: "The final platforms for which the Docker image was built."
    value: "${{ steps.prepare-final-params.outputs.platforms }}"

runs:
  using: "composite"
  steps:
    - name: Validate inputs.registry
      shell: bash
      env:
        REG: ${{ inputs.registry }}
      run: |
        if [ -z "${REG+x}" ] || [ -z "${REG}" ]; then
          echo "REGISTRY='ghcr.io'" >> $GITHUB_ENV
        else
          echo "REGISTRY=$REG" >> $GITHUB_ENV
        fi

    - name: Validate docker.io login params
      if: ${{ contains(env.REGISTRY, 'docker.io') && (! inputs.docker-io-login || ! inputs.docker-io-token) && (inputs.dry-run != 'true') }}
      shell: bash
      run: |
        echo "docker.io set as a registry, but docker-io-login and/or docker-io-token not provided."
        exit 1

    - name: Parse Component JSON
      id: extract_component
      shell: bash
      env:
        COMPONENT: ${{ inputs.component }}
      run: |
        # Parse the input JSON object directly
        component_from_json=$(echo "$COMPONENT" | jq 'if type=="array" then .[0] else . end')

        component_name=$(echo "$component_from_json" | jq -r '.name // "default"')
        component_file=$(echo "$component_from_json" | jq -r '.dockerfile // .file // "./Dockerfile"')
        component_context=$(echo "$component_from_json" | jq -r '.build_context // .context // "."')
        component_build_args=$(echo "$component_from_json" | jq -r '.arguments // empty')

        # Convert comma-separated build args to newline-separated
        if [ -n "$component_build_args" ] && [[ "$component_build_args" == *","* ]]; then
          component_build_args=$(echo "$component_build_args" | tr ',' '\n')
        fi

        {
          echo "name=$component_name"
          echo "file=$component_file"
          echo "ctx=$component_context"
          echo "build_args=$component_build_args"
        } >> "$GITHUB_OUTPUT"

    - name: Prepare Image Name
      shell: bash
      env:
        CUSTOM_IMAGE_NAME: ${{ inputs.custom-image-name }}
        COMPONENT_NAME: ${{ steps.extract_component.outputs.name }}
        DOCKER_IO_LOGIN: ${{ inputs.docker-io-login }}
      run: |
        IFS='/' read -r owner repo <<< "$GITHUB_REPOSITORY"

        CONTAINER_NAME="$repo"

        if [ -n "$COMPONENT_NAME" ] && [ "$COMPONENT_NAME" != "default" ]; then
          CONTAINER_NAME="$COMPONENT_NAME"
        fi
        if [ -n "$CUSTOM_IMAGE_NAME" ]; then
          CONTAINER_NAME="$CUSTOM_IMAGE_NAME"
        fi

        echo "CONTAINER_NAME=$CONTAINER_NAME" >> "$GITHUB_OUTPUT"

        echo "CONTAINER_NAME=$CONTAINER_NAME" >> "$GITHUB_ENV"
        echo "GHCR_OWNER=$(echo "$owner" | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_ENV"
        echo "DOCKER_OWNER=$DOCKER_IO_LOGIN" >> "$GITHUB_ENV"

        echo "CONTAINER_NAME=$CONTAINER_NAME"
        echo "GHCR_OWNER=$GHCR_OWNER"
        echo "DOCKER_OWNER=$DOCKER_OWNER"

    - name: Prepare Image ghcr.io URL
      if: ${{ contains(env.REGISTRY, 'ghcr.io') }}
      shell: bash
      run: |
        echo "GHCR_URL=ghcr.io/${{ env.GHCR_OWNER }}/${{ env.CONTAINER_NAME }}"
        echo "GHCR_URL=ghcr.io/${{ env.GHCR_OWNER }}/${{ env.CONTAINER_NAME }}" >> $GITHUB_ENV

    - name: Prepare Image docker.io URL
      if: ${{ contains(env.REGISTRY, 'docker.io') }}
      shell: bash
      run: |
        echo "DOCKER_URL=${{ env.DOCKER_OWNER }}/${{ env.CONTAINER_NAME }}"
        echo "DOCKER_URL=${{ env.DOCKER_OWNER }}/${{ env.CONTAINER_NAME }}" >> $GITHUB_ENV

    - name: Checkout Repository
      if: ${{ inputs.checkout == 'true' }}
      uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 #v6.0.1
      with:
        ref: ${{ inputs.ref }}
        persist-credentials: false

    - name: Display Debug Information
      shell: bash
      env:
        CUSTOM_IMAGE_NAME: ${{ inputs.custom-image-name }}
      run: |
        echo "custom-image-name: ${CUSTOM_IMAGE_NAME:-empty}"
        echo "env CONTAINER_NAME: ${{ env.CONTAINER_NAME }}"

        if [ -n "${DOCKER_OWNER}" ]; then
          echo "env DOCKER_OWNER: ${DOCKER_OWNER}"
        fi
        if [ -n "${GHCR_OWNER}" ]; then
          echo "env GHCR_OWNER: ${GHCR_OWNER}"
        fi
        echo "ref: ${{ inputs.ref }}"
        echo "GITHUB_REPOSITORY: ${{ github.repository }}"
        echo "GITHUB_REF: ${{ github.ref }}"
        if [ -n "${DOCKER_URL}" ]; then
          echo "docker.io URL: ${DOCKER_URL}"
        fi
        if [ -n "${GHCR_URL}" ]; then
          echo "ghcr.io URL: ${GHCR_URL}"
        fi

        echo "::group::üêã MANAGEMENT Dockerfile (alpine)"
        cat ${{ steps.extract_component.outputs.file }}
        echo "::endgroup::"

    - name: Download Artifact
      if: ${{ inputs.download-artifact == 'true' }}
      uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 #v6.0.0
      with:
        name: ${{ inputs.download-artifact-name }}
        path: ${{ inputs.download-artifact-path != '' && inputs.download-artifact-path || '.' }}
        merge-multiple: ${{ inputs.download-artifact-merge-multiple == 'true' }}

    - name: Set up QEMU
      if: ${{ inputs.setup-qemu == 'true' && inputs.skip-qemu-buildx != 'true' }}
      uses: docker/setup-qemu-action@c7c53464625b32c7a7e944ae62b3e17d2b600130 # v3.7.0

    - name: Set up Docker Buildx
      if: ${{ inputs.setup-buildx == 'true' && inputs.skip-qemu-buildx != 'true' }}
      uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

    - name: Log in to GitHub Container Registry
      if: ${{ contains(env.REGISTRY, 'ghcr.io') }}
      uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ env.GITHUB_TOKEN }}

    - name: Login to Docker Hub
      if: ${{ contains(env.REGISTRY, 'docker.io') }}
      uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef # v3.6.0
      with:
        username: ${{ inputs.docker-io-login }}
        password: ${{ inputs.docker-io-token }}

    - name: Extract Docker Metadata
      id: meta
      uses: docker/metadata-action@c299e40c65443455700f0fdfc63efafe5b349051 # v5.10.0
      with:
        context: ${{ inputs.context }}
        images: |
          ${{ env.GHCR_URL }}
          ${{ env.DOCKER_URL }}
        tags: |
          type=ref,event=branch
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}

    - name: Prepare Final Build Parameters
      id: prepare-final-params
      shell: bash
      env:
        TAGS_INPUT: ${{ inputs.tags }}
        META_TAGS: ${{ steps.meta.outputs.tags }}
        META_LABELS: ${{ steps.meta.outputs.labels }}
        BUILD_ARGS_INPUT: ${{ inputs.build-args }}
        BUILD_ARGS_META: ${{ steps.extract_component.outputs.build_args }}
        PLATFORMS_INPUT: ${{ inputs.platforms }}
        GHCR_URL: ${{ env.GHCR_URL }}
        DOCKER_URL: ${{ env.DOCKER_URL }}
      run: |
        set -euo pipefail

        # Prepare tags
        if [ -z "$TAGS_INPUT" ]; then
          echo "Using auto-generated tags from metadata-action"
          FINAL_TAGS="$META_TAGS"
        else
          echo "Using custom tags from inputs"
          IFS=',' read -ra TAGS <<< "$TAGS_INPUT"

          FINAL_TAGS=""
          if [ -n "${GHCR_URL:-}" ]; then
            for TAG in "${TAGS[@]}"; do
              TAG=$(echo "$TAG" | xargs)
              FINAL_TAGS="$FINAL_TAGS,$GHCR_URL:$TAG"
            done
          fi
          if [ -n "${DOCKER_URL:-}" ]; then
            for TAG in "${TAGS[@]}"; do
              TAG=$(echo "$TAG" | xargs)
              FINAL_TAGS="$FINAL_TAGS,$DOCKER_URL:$TAG"
            done
          fi
          FINAL_TAGS="${FINAL_TAGS#,}"
          FINAL_TAGS=$(echo "$FINAL_TAGS" | tr '[:upper:]' '[:lower:]')
        fi

        # Prepare build-args
        FINAL_BUILD_ARGS="${BUILD_ARGS_META:-$BUILD_ARGS_INPUT}"

        # Convert comma-separated build args to newline-separated
        if [[ "$FINAL_BUILD_ARGS" == *","* ]] && [[ "$FINAL_BUILD_ARGS" != *$'\n'* ]]; then
          echo "Converting comma-separated build-args to newline-separated"
          FINAL_BUILD_ARGS=$(echo "$FINAL_BUILD_ARGS" | tr ',' '\n')
        fi

        echo "Using build-args: ${BUILD_ARGS_META:+from component metadata}${BUILD_ARGS_META:-from inputs}"

        # Prepare platforms
        FINAL_PLATFORMS="$PLATFORMS_INPUT"

        echo "Final tags: $FINAL_TAGS"
        echo "Final labels: $META_LABELS"
        echo "Final build-args: $FINAL_BUILD_ARGS"
        echo "Final platforms: $FINAL_PLATFORMS"

        echo "FINAL_TAGS=$FINAL_TAGS" >> "$GITHUB_ENV"
        echo "FINAL_LABELS=$META_LABELS" >> "$GITHUB_ENV"
        echo "FINAL_BUILD_ARGS=$FINAL_BUILD_ARGS" >> "$GITHUB_ENV"
        echo "FINAL_PLATFORMS=$FINAL_PLATFORMS" >> "$GITHUB_ENV"

        echo "tags=$FINAL_TAGS" >> "$GITHUB_OUTPUT"
        {
          echo "labels<<EOF"
          echo "$META_LABELS"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"
        {
          echo "build_args<<EOF"
          echo "$FINAL_BUILD_ARGS"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"
        echo "platforms=$FINAL_PLATFORMS" >> "$GITHUB_OUTPUT"

    - name: Build and Push Docker Image
      uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83 # v6.18.0
      id: dockerbuild
      with:
        provenance: false
        sbom: ${{ inputs.sbom == 'true' && 'true' || 'false' }}
        context: ${{ steps.extract_component.outputs.ctx }}
        file: ${{ steps.extract_component.outputs.file }}
        push: ${{ inputs.dry-run == 'true' && 'false' || 'true' }}
        tags: ${{ env.FINAL_TAGS }}
        labels: ${{ env.FINAL_LABELS }}
        platforms: ${{ env.FINAL_PLATFORMS }}
        build-args: ${{ env.FINAL_BUILD_ARGS }}

    - name: Output result
      if: ${{ ! (inputs.dry-run == 'true') }}
      id: output_result
      shell: bash
      run: |
        set -euo pipefail

        IMAGE_NAME_FULL="${{ fromJson(steps.dockerbuild.outputs.metadata)['image.name'] }}"
        IMAGE_NAME_FULL="${IMAGE_NAME_FULL%%,*}"

        if [ -z "$IMAGE_NAME_FULL" ]; then
          echo "ERROR: IMAGE_NAME_FULL is empty. Check dockerbuild.outputs.metadata / image.name"
          exit 1
        fi

        echo "IMAGE_NAME_FULL=$IMAGE_NAME_FULL"

        IMAGE_NAME="${IMAGE_NAME_FULL%%:*}"
        TAG="${IMAGE_NAME_FULL##*:}"

        if [ -z "$IMAGE_NAME" ] || [ -z "$TAG" ]; then
          echo "ERROR: IMAGE_NAME or TAG is empty. Got: IMAGE_NAME='$IMAGE_NAME', TAG='$TAG'"
          exit 1
        fi

        DIGEST="${{ steps.dockerbuild.outputs.digest }}"
        if [ -z "$DIGEST" ]; then
          echo "ERROR: DIGEST is empty. Check dockerbuild.outputs.digest"
          exit 1
        fi

        ALG="${DIGEST%%:*}"
        DIGEST_NO_PREFIX="${DIGEST##*:}"
        DIGEST_SHORT="${DIGEST_NO_PREFIX:0:12}"

        GROUP=""

        VERSION="$TAG"

        BASENAME="$(basename "$IMAGE_NAME")"
        FILENAME="${BASENAME}-${TAG}-${DIGEST_SHORT}.json"

        echo ">>> IMAGE_NAME        = $IMAGE_NAME"
        echo ">>> TAG               = $TAG"
        echo ">>> DIGEST            = $DIGEST"
        echo ">>> DIGEST_SHORT(12)  = $DIGEST_SHORT"
        echo ">>> FILENAME          = $FILENAME"

        REFERENCE="${IMAGE_NAME}:${VERSION}"

        cat <<EOF > "$FILENAME"
        {
          "type": "container",
          "mime-type": "application/vnd.docker.image",
          "name": "${CONTAINER_NAME}",
          "group": "${GROUP}",
          "version": "${VERSION}",
          "hashes": [
            {
              "alg": "${ALG}",
              "content": "${DIGEST_NO_PREFIX}"
            }
          ],
          "reference": "${REFERENCE}"
        }
        EOF

        echo "image_name=$IMAGE_NAME_FULL" >> "$GITHUB_OUTPUT"
        echo "metadata_path=$PWD/$FILENAME" >> "$GITHUB_OUTPUT"
        echo "metadata_filename=$FILENAME" >> "$GITHUB_OUTPUT"

    - name: "Upload metadata file"
      if: ${{ ! (inputs.dry-run == 'true') }}
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.output_result.outputs.metadata_filename }}
        path: ${{ steps.output_result.outputs.metadata_path }}
